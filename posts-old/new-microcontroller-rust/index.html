<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Jack's blog and portfolio."><link rel="shortcut icon" href=https://blog.jackgreenberg.co/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Getting started with &lt;MICROCONTROLLER> in Rust</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel=stylesheet></head><body><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><header class=banner><h2><a href=https://blog.jackgreenberg.co>Jack Greenberg</a></h2><nav><ul><li><a href=/about/ title=about>about</a></li><li><a href=/projects/ title=projects>projects</a></li><li><a href=/resume.pdf title=resume>resume</a></li><li><button id=toggle-dark><svg id="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><svg id="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button></li></ul></nav></header><main id=content><article><header id=post-header><h1>Getting started with &lt;MICROCONTROLLER> in Rust</h1><div><time>October 4, 2022</time></div></header><p>Embedded Rust is amazing. Between the sophisticated tooling, common set of
peripheral abstractions (HALs), and its memory-safety, there is a lot to like.
However, all embedded systems development is challenging for one crucial reason:
the hardware. Specifically, there are so many microcontrollers that it can be
hard to know which to choose, or, if you have a random one, how to use it.</p><p>In this post, I hope to highlight the process of writing a blinky application
for an arbitrary microcontroller. We&rsquo;ll use the STM32H750VBT6 microcontroller.</p><p>I&rsquo;ll start by determining if it even possible to use this microcontroller
(spoiler alert: it is). Then, we&rsquo;ll work through adapting the
<code>cortex-m-quickstart</code> template repository to fit our needs. Finally, we&rsquo;ll write
the application, enable logging over ITM (a challenge in and of itself), and
test it on hardware!</p><h2 id=prelude-impulse-buying>Prelude: Impulse Buying</h2><p>A while back, I was looking for a new development board to play around with. I
wanted a microcontroller that had a memory-protection unit (MPU) so that I could
run [Hubris], the embedded operating system by [Oxide].</p><p>I found [this board] on Adafruit that has an STM32H750VBT6 and bought it. It&rsquo;s
got an LCD screen, a button, an LED, and an SD card slot. Plenty of stuff to
play around with&mldr;</p><h2 id=step-one-sanity-check>Step one: sanity check</h2><p>The basis for most embedded Rust code is the <em>peripheral access crate</em>, or PAC.
This is a library that contains definitions for all of the memory-mapped
registers of the microcontroller, which is the method by which we interact with
hardware peripherals like SPI and GPIO.</p><p>However, we usually don&rsquo;t use the PAC&mdash;we use a HAL, or <em>hardware abstraction
library</em>. The HAL provides an abstraction over the PAC, meaning that instead of
writing a one to a specific bit in a register to set a GPIO pin high, we can
just call <code>pin.set_high()</code> and the <code>set_high</code> method handles writing the
register for us.</p><p>PACs and HALs are often idenfitied by the <em>family</em> of microcontroller. An
STM32F103C8T6 would be classified in the STM32F1 family, whereas our chip
(STM32H750VBT6) is an STM32H7 microcontroller. So the PAC for our
microcontroller is called <code>stm32h7</code> and the HAL is called <code>stm32h7xx-hal</code>.
Looking at the <a href=https://crates.io/crates/stm32h7>documentation for the PAC</a>, it seems like our microcontroller
isn&rsquo;t supported&mldr; Hm. That is unfortunate. In any case, let&rsquo;s check the HAL:</p><blockquote><h4 id=supported-configurations>Supported Configurations</h4><ul><li>stm32h743v (Revision V: stm32h743, stm32h742, stm32h750)</li></ul></blockquote><p>There it is! The &ldquo;stm32h750&rdquo;. It is a bit confusing that it is wrapped up with
<code>stm32h743v</code>, but I think this is good enough for us to move forward with the
HAL.</p><h2 id=step-two-git-clone-cargo-generate>Step two: <del><code>git clone</code></del> <code>cargo generate</code></h2><p>Now that we&rsquo;ve verified that we have a HAL we can use to simplify our
programming, let&rsquo;s start setting up our application. Instead of starting from
scratch, we can use the <a href=https://github.com/rust-embedded/cortex-m-quickstart><code>cortex-m-quickstart</code></a> template repository. This gives
us boilerplate code and configuration files that we can tweak to get our system
up and running much quicker.</p><p>We&rsquo;ll want to start by installing <code>cargo-generate</code>, and once we have that, we
can run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</span></span></code></pre></div><p>After we enter into our repository, we see a bunch of files. Our code will live
in the <code>src/</code> folder, and the rest of the files are used for configuration of
our code. Let&rsquo;s start there.</p><p>To start there are three files we will need to edit before we start on code:</p><ol><li><code>memory.x</code>: Defines the memory layout of our microcontroller</li><li><code>.cargo/config.toml</code>: Defines the configuration for building our application</li><li><code>Cargo.toml</code>: Defines what crates we use in our code</li></ol><h3 id=linker-script-memoryx>Linker Script: <code>memory.x</code></h3><p>To start, we need to tell our compiler what the memory layout of our chip is.
This is defined by your chip, so you&rsquo;ll have to read the datasheet:</p><p><img src=images/memory-table.png alt></p></article></main><footer id=footer>Copyright (c) 2022 Jack Greenberg</footer></body><script>let darkModeState=!1;const useDark=window.matchMedia("(prefers-color-scheme: dark)"),toggle_button=document.querySelector("#toggle-dark");function toggleDarkMode(e){document.documentElement.classList.toggle("dark-mode",e),darkModeState=e}toggleDarkMode(localStorage.getItem("dark-mode")=="true"),useDark.addListener(e=>toggleDarkMode(e.matches)),toggle_button.addEventListener("click",()=>{darkModeState=!darkModeState,toggleDarkMode(darkModeState),localStorage.setItem("dark-mode",darkModeState)})</script></html>