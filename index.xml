<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jack Greenberg</title><link>https://blog.jackgreenberg.co/</link><description>Recent content on Jack Greenberg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 12 Dec 2022 11:15:07 -0500</lastBuildDate><atom:link href="https://blog.jackgreenberg.co/index.xml" rel="self" type="application/rss+xml"/><item><title>Reflection on Embedded Rust</title><link>https://blog.jackgreenberg.co/posts/reflection/</link><pubDate>Mon, 12 Dec 2022 11:15:07 -0500</pubDate><guid>https://blog.jackgreenberg.co/posts/reflection/</guid><description>This semester I decided to embark on an independent study of embedded Rust. Having worked extensively in C, I wanted to explore a new frontier of embedded systems. After three months and a handful of projects, I have come up with a few main takeaways:
The tooling ecosystem for embedded Rust makes writing, testing, and debugging code far simpler than the tooling ecosystem for C. Rust&amp;rsquo;s patterns of traits and implementations makes for more idiomatic embedded systems that lend themselves to different hardware platforms.</description></item><item><title>Using Rust's Xtask to Automate Remote Embedded Development</title><link>https://blog.jackgreenberg.co/posts/xtask/</link><pubDate>Sun, 11 Dec 2022 23:39:26 -0500</pubDate><guid>https://blog.jackgreenberg.co/posts/xtask/</guid><description>Cargo is an incredibly powerful tool. Not only does it manage building, running, and testing code, but it also serves as a package manager. However, there are limitations to Cargo. A tool like GNU Make provides a framework for running arbitrary commands to complete tasks, but requires a lot of configuration, whereas Cargo has a more limited scope but is effectively plug and play.
In this post, we&amp;rsquo;ll look at xtask, a tool that extends the functionality of Cargo to execute arbitrary code written in&amp;mdash;you guessed it&amp;mdash;Rust.</description></item><item><title>Remote Embedded Development</title><link>https://blog.jackgreenberg.co/posts/remote-embedded/</link><pubDate>Mon, 28 Nov 2022 18:09:49 -0800</pubDate><guid>https://blog.jackgreenberg.co/posts/remote-embedded/</guid><description>I hate wires. Being a student of embedded systems for the last couple years, I have had plenty of experience lugging wires around, finding and losing small screw drivers for screw pin terminals, and plugging and unplugging dev boards from debuggers.
In this post, I&amp;rsquo;ll talk about how I found a low-cost solution to my woes and how anyone can set up something similar.
Background While working on an embedded Rust project for a class, I found myself carrying a small STM32H750 development board in my backpack, along with a USB cable, a debugger, a USB cable for the debugger, and lots of jumper wires.</description></item><item><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 2: Blinky)</title><link>https://blog.jackgreenberg.co/posts/blinky-stm32h750/</link><pubDate>Wed, 05 Oct 2022 16:18:56 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/blinky-stm32h750/</guid><description>In my previous post, I went over the setup and configuration of an embedded application in Rust, trying to stay as generic as possible but provide specific examples. In this post, I&amp;rsquo;ll focus a little closer on the specific microcontroller I am using, but try to generalize where possible.
Today, we&amp;rsquo;ll work on getting a blinky program running. We&amp;rsquo;ll start by creating the basic structure of all embedded applications (a main function with an infinite loop).</description></item><item><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 1: Setup)</title><link>https://blog.jackgreenberg.co/posts/new-microcontroller-rust/new-microcontroller-rust/</link><pubDate>Tue, 04 Oct 2022 16:18:56 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/new-microcontroller-rust/new-microcontroller-rust/</guid><description>Embedded Rust is amazing. Between the sophisticated tooling, common set of peripheral abstractions (HALs), and its memory-safety, there is a lot to like. However, all embedded systems development is challenging for one crucial reason: the hardware. Specifically, there are so many microcontrollers that it can be hard to know which to choose, or, if you have a random one, how to use it.
In this post, I hope to highlight the process of writing a blinky application for an arbitrary microcontroller.</description></item><item><title>Add QR Codes to your KiCAD PCBs</title><link>https://blog.jackgreenberg.co/posts/kicad_qr/</link><pubDate>Fri, 23 Sep 2022 13:04:16 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/kicad_qr/</guid><description>Testing and debugging PCBs can be challenging. There are lots of resource you need, including the schematic, documentation, data sheets, and more. Hunting all of this information down can be a pain. It would be great if there was a way to collect all this information in one place and make it easily accessible&amp;hellip;
Imagine this: a QR code on the back of your PCB. You scan it, and it brings up a list of links including your schematic, documentation, important datasheets, interactive HTML BoM, or whatever else you want.</description></item><item><title>Embedded Rust From Embedded C: Peripherals</title><link>https://blog.jackgreenberg.co/posts/embedded-rust-from-embedded-c/</link><pubDate>Tue, 20 Sep 2022 17:09:37 +0200</pubDate><guid>https://blog.jackgreenberg.co/posts/embedded-rust-from-embedded-c/</guid><description>As an embedded C developer, I have become entrenched in the ways of the language. Things like using structs to access registers or opaque pointers for passing data around1. Rust provides a whole new memory model that makes writing any program safer at no extra cost. In the next few posts we&amp;rsquo;ll explore some of the patterns that make embedded Rust special and compare them to how things are done in C.</description></item></channel></rss>