<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Jack's blog and portfolio."><link rel="shortcut icon" href=https://blog.jackgreenberg.co/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 1: Setup)</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel=stylesheet></head><body><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><header class=banner><h2><a href=https://blog.jackgreenberg.co>Jack Greenberg</a></h2><nav><ul><li><a href=/about/ title=about>about</a></li><li><a href=/projects/ title=projects>projects</a></li><li><a href=/resume.pdf title=resume>resume</a></li><li><button id=toggle-dark><svg id="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><svg id="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button></li></ul></nav></header><main id=content><article><header id=post-header><h1>Getting started with &lt;MICROCONTROLLER> in Rust (Part 1: Setup)</h1><div><time>October 4, 2022</time></div></header><details id=toc-inline><summary><b>Table of Contents</b></summary><nav id=TableOfContents><ul><li><a href=#prelude-impulse-buying>Prelude: Impulse Buying</a></li><li><a href=#step-one-sanity-check>Step one: sanity check</a><ul><li></li></ul></li><li><a href=#step-two-git-clone-cargo-generate>Step two: <code>git clone</code> <code>cargo generate</code></a><ul><li><a href=#memory-configuration-memoryx>Memory Configuration: <code>memory.x</code></a></li><li><a href=#compiler-configuration-cargoconfigtoml>Compiler Configuration: <code>.cargo/config.toml</code></a></li><li><a href=#application-configuration-cargotoml>Application Configuration: <code>Cargo.toml</code></a></li></ul></li></ul></nav></details><p>Embedded Rust is amazing. Between the sophisticated tooling, common set of
peripheral abstractions (HALs), and its memory-safety, there is a lot to like.
However, all embedded systems development is challenging for one crucial reason:
the hardware. Specifically, there are so many microcontrollers that it can be
hard to know which to choose, or, if you have a random one, how to use it.</p><p>In this post, I hope to highlight the process of writing a blinky application
for an arbitrary microcontroller. We&rsquo;ll use the STM32H750VBT6 microcontroller.</p><p>I&rsquo;ll start by determining if it even possible to use this microcontroller
(spoiler alert: it is). Then, we&rsquo;ll work through adapting the
<code>cortex-m-quickstart</code> template repository to fit our needs. Finally, we&rsquo;ll write
the application, enable logging over ITM (a challenge in and of itself), and
test it on hardware!</p><h2 id=prelude-impulse-buying>Prelude: Impulse Buying</h2><p>A while back, I was looking for a new development board to play around with. I
wanted a microcontroller that had a memory-protection unit (MPU) so that I could
run [Hubris], the embedded operating system by [Oxide].</p><p>I found [this board] on Adafruit that has an STM32H750VBT6 and bought it. It&rsquo;s
got an LCD screen, a button, an LED, and an SD card slot. Plenty of stuff to
play around with&mldr;</p><h2 id=step-one-sanity-check>Step one: sanity check</h2><p>The basis for most embedded Rust code is the <em>peripheral access crate</em>, or PAC.
This is a library that contains definitions for all of the memory-mapped
registers of the microcontroller, which is the method by which we interact with
hardware peripherals like SPI and GPIO.</p><p>However, we usually don&rsquo;t use the PAC&mdash;we use a HAL, or <em>hardware abstraction
library</em>. The HAL provides an abstraction over the PAC, meaning that instead of
writing a one to a specific bit in a register to set a GPIO pin high, we can
just call <code>pin.set_high()</code> and the <code>set_high</code> method handles writing the
register for us.</p><p>PACs and HALs are often idenfitied by the <em>family</em> of microcontroller. An
STM32F103C8T6 would be classified in the STM32F1 family, whereas our chip
(STM32H750VBT6) is an STM32H7 microcontroller. So the PAC for our
microcontroller is called <code>stm32h7</code> and the HAL is called <code>stm32h7xx-hal</code>.
Looking at the <a href=https://crates.io/crates/stm32h7>documentation for the PAC</a>, it seems like our microcontroller
isn&rsquo;t supported&mldr; Hm. That is unfortunate. In any case, let&rsquo;s check the HAL:</p><blockquote><h4 id=supported-configurations>Supported Configurations</h4><ul><li>stm32h743v (Revision V: stm32h743, stm32h742, stm32h750)</li></ul></blockquote><p>There it is! The &ldquo;stm32h750&rdquo;. It is a bit confusing that it is wrapped up with
<code>stm32h743v</code>, but I think this is good enough for us to move forward with the
HAL.</p><h2 id=step-two-git-clone-cargo-generate>Step two: <del><code>git clone</code></del> <code>cargo generate</code></h2><p>Now that we&rsquo;ve verified that we have a HAL we can use to simplify our
programming, let&rsquo;s start setting up our application. Instead of starting from
scratch, we can use the <a href=https://github.com/rust-embedded/cortex-m-quickstart><code>cortex-m-quickstart</code></a> template repository. This gives
us boilerplate code and configuration files that we can tweak to get our system
up and running much quicker.</p><p>We&rsquo;ll want to start by installing <code>cargo-generate</code>, and once we have that, we
can run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</span></span></code></pre></div><p>After we enter into our repository, we see a bunch of files. Our code will live
in the <code>src/</code> folder, and the rest of the files are used for configuration of
our code. Let&rsquo;s start there.</p><p>To start there are three files we will need to edit before we start on code:</p><ol><li><code>memory.x</code>: Defines the memory layout of our microcontroller</li><li><code>.cargo/config.toml</code>: Defines the configuration for building our application</li><li><code>Cargo.toml</code>: Defines what crates we use in our code</li></ol><h3 id=memory-configuration-memoryx>Memory Configuration: <code>memory.x</code></h3><p>To start, we need to tell our compiler what the memory layout of our chip is
using a <em>linker script</em>. This is defined by your chip, so you&rsquo;ll have to read
the datasheet. The memory for our chip is pretty confusing. There are six types
of RAM (DTCM, SRAM1, 2, 3, and 4, and <em>back-up</em> SRAM), as well as three types of
flash (ITCM, a flash memory bank, and &ldquo;System Memory&rdquo;). There are tradeoffs
between the different types, but for now, we will just use DTCM for data and
the flash memory bank for code<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>According to the datasheet, we have 128K of flash (addresses
0x08000000&ndash;0x0801FFFF) and 128K of DTCM (addresses 0x20000000&ndash;0x2001FFFF). We
can indicate that to Rust in <code>memory.x</code>:</p><pre tabindex=0><code>MEMORY {
  FLASH : ORIGIN = 0x08000000, LENGTH = 128K
  RAM : ORIGIN = 0x20000000, LENGTH = 128K
}
</code></pre><p>This is all we need to tell Rust how to place the code and data for our program.
Next, let&rsquo;s configure the compilation stage.</p><h3 id=compiler-configuration-cargoconfigtoml>Compiler Configuration: <code>.cargo/config.toml</code></h3><p>This file configures <code>cargo</code>, Rust&rsquo;s build system and package manager. There are
only two changes we need to make here:</p><ol><li><p><strong>Choose a &ldquo;runner&rdquo;.</strong> The runner is the command that gets executed when we
type <code>cargo run</code> into our terminal. In normal Rust programming, this will
just execute your program on your machine. However, we cannot execute
embedded Rust code on our laptops or PCs <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Instead, we are going to use
<code>openocd</code> to setup a debug server that we can connect to with GDB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>runner</span> <span class=p>=</span> <span class=s2>&#34;openocd&#34;</span>
</span></span></code></pre></div><p>When we go to flash our device, we will use <code>cargo flash</code>.</p></li></ol><ol start=2><li><p><strong>Choose our target platform.</strong> We need to tell <code>cargo</code> which target platform
we are compiling for. In a non-embedded context, this might be something like
<code>x86_64-unknown-linux-gnu</code>. In our context, it will depend on the
architecture of the microcontroller&rsquo;s core. The datasheet will tell you if
you have a Cortex M0, M3, etc. as well as whether or not your device has a
<em>floating point unit</em>, or FPU. The <code>cortex-m-quickstart</code> template
conveniently lists our options. Our microcontroller is a Cortex M7 core with
an FPU, so we will choose</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>target</span> <span class=p>=</span> <span class=s2>&#34;thumbv7em-none-eabihf&#34;</span>
</span></span></code></pre></div></li></ol><p>Finally, we will configure our application and add package dependencies so that
we don&rsquo;t have to write a bunch of hardware libraries from scratch.</p><h3 id=application-configuration-cargotoml>Application Configuration: <code>Cargo.toml</code></h3><p>As we mentioned before, we want to use a HAL to write our software so that we
don&rsquo;t have to spend time worrying about writing specific values into specific
memory-mapped registers. Our HAL is the <code>stm32h7xx-hal</code>, but if you are using a
different chip, you should find the associated HAL. You can find a good list of
HALs <a href=https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates>here</a>.</p><p>In our <code>Cargo.toml</code> file, we will add the following under the <code>[dependencies]</code>
header:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-toml data-lang=toml><span class=line><span class=cl><span class=nx>stm32h7xx-hal</span> <span class=p>=</span> <span class=p>{</span> <span class=nx>version</span> <span class=p>=</span> <span class=s2>&#34;0.12.2&#34;</span><span class=p>,</span> <span class=nx>features</span> <span class=p>=</span> <span class=p>[</span><span class=s2>&#34;stm32h750v&#34;</span><span class=p>]</span> <span class=p>}</span>
</span></span></code></pre></div><p>In our case, we specify a feature as listed in the <em><a href=https://docs.rs/crate/stm32h7xx-hal/0.12.2/features>crates.io</a></em> page that
chooses the correct library code for our specific microcontroller.</p><hr><p>With all of that, we are finally ready to start writing code! In the next part,
we will write a blinky program on our microcontroller.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The main reason for choosing DTCM over the other SRAM regions is that I
was having some trouble with the SRAM regions where my device would crash due
to some memory issue. That debugging story will be for another time.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Yes, there is some support for emulation using QEMU, but we&rsquo;ll just look
the other way for now&mldr;&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><footer id=footer>Copyright (c) 2022 Jack Greenberg</footer></body><script>let darkModeState=!1;const useDark=window.matchMedia("(prefers-color-scheme: dark)"),toggle_button=document.querySelector("#toggle-dark");function toggleDarkMode(e){document.documentElement.classList.toggle("dark-mode",e),darkModeState=e}toggleDarkMode(localStorage.getItem("dark-mode")=="true"),useDark.addListener(e=>toggleDarkMode(e.matches)),toggle_button.addEventListener("click",()=>{darkModeState=!darkModeState,toggleDarkMode(darkModeState),localStorage.setItem("dark-mode",darkModeState)})</script></html>