<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jack Greenberg</title><link>https://blog.jackgreenberg.co/posts/</link><description>Recent content in Posts on Jack Greenberg</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Oct 2022 16:18:56 -0400</lastBuildDate><atom:link href="https://blog.jackgreenberg.co/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 2: Blinky)</title><link>https://blog.jackgreenberg.co/posts/blinky-stm32h750/</link><pubDate>Wed, 05 Oct 2022 16:18:56 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/blinky-stm32h750/</guid><description>In my previous post, I went over the setup and configuration of an embedded application in Rust, trying to stay as generic as possible but provide specific examples. In this post, I&amp;rsquo;ll focus a little closer on the specific microcontroller I am using, but try to generalize where possible.
Today, we&amp;rsquo;ll work on getting a blinky program running. We&amp;rsquo;ll start by creating the basic structure of all embedded applications (a main function with an infinite loop).</description></item><item><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 1: Setup)</title><link>https://blog.jackgreenberg.co/posts/new-microcontroller-rust/new-microcontroller-rust/</link><pubDate>Tue, 04 Oct 2022 16:18:56 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/new-microcontroller-rust/new-microcontroller-rust/</guid><description>Embedded Rust is amazing. Between the sophisticated tooling, common set of peripheral abstractions (HALs), and its memory-safety, there is a lot to like. However, all embedded systems development is challenging for one crucial reason: the hardware. Specifically, there are so many microcontrollers that it can be hard to know which to choose, or, if you have a random one, how to use it.
In this post, I hope to highlight the process of writing a blinky application for an arbitrary microcontroller.</description></item><item><title>Add QR Codes to your KiCAD PCBs</title><link>https://blog.jackgreenberg.co/posts/kicad_qr/</link><pubDate>Fri, 23 Sep 2022 13:04:16 -0400</pubDate><guid>https://blog.jackgreenberg.co/posts/kicad_qr/</guid><description>Testing and debugging PCBs can be challenging. There are lots of resource you need, including the schematic, documentation, data sheets, and more. Hunting all of this information down can be a pain. It would be great if there was a way to collect all this information in one place and make it easily accessible&amp;hellip;
Imagine this: a QR code on the back of your PCB. You scan it, and it brings up a list of links including your schematic, documentation, important datasheets, interactive HTML BoM, or whatever else you want.</description></item><item><title>Embedded Rust From Embedded C: Peripherals</title><link>https://blog.jackgreenberg.co/posts/embedded-rust-from-embedded-c/</link><pubDate>Tue, 20 Sep 2022 17:09:37 +0200</pubDate><guid>https://blog.jackgreenberg.co/posts/embedded-rust-from-embedded-c/</guid><description>As an embedded C developer, I have become entrenched in the ways of the language. Things like using structs to access registers or opaque pointers for passing data around1. Rust provides a whole new memory model that makes writing any program safer at no extra cost. In the next few posts we&amp;rsquo;ll explore some of the patterns that make embedded Rust special and compare them to how things are done in C.</description></item></channel></rss>