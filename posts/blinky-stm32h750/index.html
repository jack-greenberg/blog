<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Jack's blog and portfolio."><link rel="shortcut icon" href=https://blog.jackgreenberg.co/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Getting started with &lt;MICROCONTROLLER> in Rust (Part 2: Blinky)</title><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel=stylesheet></head><body><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><header class=banner><h2><a href=https://blog.jackgreenberg.co>Jack Greenberg</a></h2><nav><ul><li><a href=/about/ title=about>about</a></li><li><a href=/projects/ title=projects>projects</a></li><li><a href=/resume.pdf title=resume>resume</a></li><li><button id=toggle-dark><svg id="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg><svg id="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button></li></ul></nav></header><main id=content><article><header id=post-header><h1>Getting started with &lt;MICROCONTROLLER> in Rust (Part 2: Blinky)</h1><div><time>October 5, 2022</time></div></header><details id=toc-inline><summary><b>Table of Contents</b></summary><nav id=TableOfContents><ul><li><a href=#initialization>Initialization</a><ul><li><a href=#aside-hardware-peripherals-in-rust>Aside: Hardware Peripherals in Rust</a></li></ul></li><li><a href=#configuring-gpios>Configuring GPIOs</a></li><li><a href=#loop>Loop</a></li><li><a href=#zooming-back-out>Zooming back out</a></li><li><a href=#artifacts-and-resources>Artifacts and Resources</a></li></ul></nav></details><p>In my <a href=/posts/new-microcontroller-rust/new-microcontroller-rust/>previous post</a>, I went over the setup and configuration of an embedded
application in Rust, trying to stay as generic as possible but provide specific
examples. In this post, I&rsquo;ll focus a little closer on the specific
microcontroller I am using, but try to generalize where possible.</p><p>Today, we&rsquo;ll work on getting a blinky program running. We&rsquo;ll start by creating
the basic structure of all embedded applications (a <code>main</code> function with an
infinite loop). Next, we&rsquo;ll go over the initialization code that sets up our
hardware, followed by filling in our infinite loop so that we can blink an LED.</p><p>On the board I am using, there is an LED connected to pin PE3, so that is what
we will be blinking. The goal is to have a program that turns the LED on for
half a second and then turns it off for half a second.</p><hr><p>As you will recall from Part 1, we started with the <code>cortex-m-quickstart</code>
template for our application. Cleaning up some of the comments, our
<code>src/main.rs</code> file looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// src/main.rs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#![no_std]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#![no_main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>panic_halt</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>_</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>cortex_m</span>::<span class=n>asm</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>cortex_m_rt</span>::<span class=n>entry</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[entry]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Init
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>asm</span>::<span class=n>nop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// TODO: Fill me in
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We have our basic embedded application architecture with an [entry-point] (<code>main</code>), space
for initialization code, and an infinite loop.</p><p>Let&rsquo;s start filling it in.</p><h2 id=initialization>Initialization</h2><p>In our initialization, we need access to the <em>device</em> peripherals like the power
configuration and GPIOs (unique to the microcontroller), as well as the <em>core</em>
peripherals (unique to Cortex-M devices) like the NVIC and SysTick timer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Device peripherals (i.e. GPIO)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>dp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pac</span>::<span class=n>Peripherals</span>::<span class=n>take</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Core peripherals (i.e. NVIC)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=n>cp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cortex_m</span>::<span class=n>Peripherals</span>::<span class=n>take</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>In order to access peripherals like GPIO, we need to enable them. In order to
enable them, we need access to the internal clock on the microcontroller. We do
that by accessing the <strong>RCC</strong> (reset and clock control) struct. We will also
need to use the <strong>PWR</strong> (power) struct in order to configure the clocks, as
instructed by the <a href=https://docs.rs/stm32h7xx-hal/latest/stm32h7xx_hal/rcc/index.html>documentation</a>:</p><blockquote><p>[RCC] peripheral must be used alongside the PWR peripheral to freeze voltage
scaling of the device.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>pwrcfg</span>: <span class=nc>stm32h7xx_hal</span>::<span class=n>pwr</span>::<span class=n>PowerConfiguration</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dp</span><span class=p>.</span><span class=n>PWR</span><span class=p>.</span><span class=n>constrain</span><span class=p>().</span><span class=n>freeze</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>rcc</span>: <span class=nc>stm32h7xx_hal</span>::<span class=n>rcc</span>::<span class=n>Rcc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dp</span><span class=p>.</span><span class=n>RCC</span><span class=p>.</span><span class=n>constrain</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>On other microcontrollers, the clocks may have a different model for
configuration. Check the examples and documentation for your HAL to get an learn
more. The following code was adapted from the <a href=https://github.com/stm32-rs/stm32h7xx-hal/tree/master/examples>examples</a> in the <code>stm32h7xx-hal</code>
library.</p><p>I was initially confused by <code>.constrain()</code> and <code>.freeze()</code>. It took a bit of
digging, but I came across <a href=https://blog.japaric.io/brave-new-io/>a great article by Jorge Aparicio</a> about the model
that Rust uses to interact with hardware peripherals (see the <strong>Aside</strong> for more
details).</p><blockquote><h3 id=aside-hardware-peripherals-in-rust>Aside: Hardware Peripherals in Rust</h3><p>In a nutshell, embedded Rust utilizes the ownership model for controlling
access to peripherals.</p><p>Starting with a concrete example, when we access <code>dp.RCC</code>, we are accessing a
struct with a bunch of members that represent the parts of the RCC registers
in our microcontroller. In C, we configure the RCC hardware block by writing
to those registers. We do a similar thing in Rust, except it&rsquo;s abstracted for
us.</p><p>Calling <code>.constrain()</code> &ldquo;consumes the original <code>RCC</code> which granted full
access to every <code>RCC</code> register&rdquo; and only allows us to modify aspects of the
register defined in a struct called <strong><code>Parts</code></strong> (it&rsquo;s not crucial to know what
is in <code>Parts</code>). In &ldquo;consuming&rdquo; a struct, we ensure that after configuration,
we can no longer use the original <code>dp.RCC</code> struct, and must instead use the
members of the <code>Parts</code> struct.</p><p>When we call <code>.freeze()</code>, we consume the <code>Parts</code> struct, preventing further
modification of struct and thus the peripherals. This ensures we don&rsquo;t have
multiple places in our code trying to change the configuration of peripherals.
Note that there are some peripherals that return a new object after calling
<code>.freeze()</code> because there are parts that make sense to modify during the
runtime of the device.</p></blockquote><p>OK, back to blinky. We gain access to the CCDR (Core Clock Distribution and
Reset) struct using the RCC, PWR, and SYSCFG registers. (If this sounds like a
lot, don&rsquo;t worry&ndash;<strong>it is</strong>. I don&rsquo;t fully understand each and every register we
are writing to. Most of this code is copied and pasted from the <a href=https://github.com/stm32-rs/stm32h7xx-hal/tree/master/examples>HAL examples</a>
and slightly tweaked until I got things working.)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>ccdr</span>: <span class=nc>stm32h7xx_hal</span>::<span class=n>rcc</span>::<span class=n>Ccdr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rcc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>sys_ck</span><span class=p>(</span><span class=mf>96.</span><span class=n>MHz</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>pclk1</span><span class=p>(</span><span class=mf>48.</span><span class=n>MHz</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>freeze</span><span class=p>(</span><span class=n>pwrcfg</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>dp</span><span class=p>.</span><span class=n>SYSCFG</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>The above code sets up the main clocks in the microcontroller at the given
frequencies, and then &ldquo;freezes&rdquo; the configuration so that it can&rsquo;t be modified.</p><p>This is the last bit of code we need for initializing the microcontroller
itself. Next, we will look at setting up GPIO specifically and blinking the LED.</p><h2 id=configuring-gpios>Configuring GPIOs</h2><p>There are a number of GPIO &ldquo;pin banks&rdquo; in the STM32 microcontrollers. They are
in a group of 16 pins and each group is assigned a letter. So you might 16 pins
on Port A, labeled <code>PA0</code>, <code>PA1</code>, &mldr;, <code>PA15</code>. To access individual pins, we have
to &ldquo;split&rdquo; the GPIO group:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>gpioe</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dp</span><span class=p>.</span><span class=n>GPIOE</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>ccdr</span><span class=p>.</span><span class=n>peripheral</span><span class=p>.</span><span class=n>GPIOE</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>The LED on our board is connected to Port E, pin 3 (<code>PE3</code>), hence using <code>GPIOE</code>.
We can use the <code>gpioe</code> variable to access the individual pins like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>led</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>gpioe</span><span class=p>.</span><span class=n>pe3</span><span class=p>.</span><span class=n>into_push_pull_output</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>We now have a variable that represents the pin our LED is attached to. We set it
to be <em>push/pull</em> as opposed to <em>open drain</em>. The difference isn&rsquo;t important for
this post.</p><p>In order to blink the LED, we need to be able to delay for a certain amount of
time. Luckily, there is a helpful abstraction we can use: <code>delay::Delay</code>! This
is a struct with methods that allow a developer to insert arbitrary-time-length
delays into their code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>delay</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>delay</span>::<span class=n>Delay</span>::<span class=n>new</span><span class=p>(</span><span class=n>cp</span><span class=p>.</span><span class=n>SYST</span><span class=p>,</span><span class=w> </span><span class=n>ccdr</span><span class=p>.</span><span class=n>clocks</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h2 id=loop>Loop</h2><p>Now we have our LED variable and our delay variable, and that is all we need to
do for initialization! After all that, we implemenet a simple 2 line loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>led</span><span class=p>.</span><span class=n>toggle</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>delay</span><span class=p>.</span><span class=n>delay_ms</span><span class=p>(</span><span class=mi>500_</span><span class=k>u16</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We toggle the LED and we delay for 500 milliseconds!</p><h2 id=zooming-back-out>Zooming back out</h2><p>In all honesty, this was a pretty large effort. It took a while to understand
how the <code>.constrain()</code>, <code>.freeze()</code>, and <code>.split()</code> methods worked. On top of
that, some of the code examples I found online were outdated and didn&rsquo;t compile
straight out of the box.</p><p>The code to get blinky running is also substantially longer than the code would
be in C. However, as I would come to learn after trying a few more advanced
things that I&rsquo;ll cover in subsequent posts, the advantages of Rust are truly
enough to make me never want to write embedded C again.</p><p>The whole I/O system that Jorge Aparicio discusses in his blog post (linked
above and at the end) is quite nice. Rust&rsquo;s use of generic types and traits also
means that code is quite easy to port over. As I will explore in the next post,
abstractions make things very easy when you have complicated systems, such as an
LCD screen driven by an external chip using SPI <em>and</em> GPIOs.</p><p>The next post will go into writing a simple program to display an image and text
on the little LCD screen of my dev board. It turns out to be far simpler than I
originally thought it might be 😅</p><h2 id=artifacts-and-resources>Artifacts and Resources</h2><ul><li><a href=https://github.com/jack-greenberg/embedded-rust-isr/blob/main/blinky/src/main.rs>Blinky with a ton of comments</a>: This is the same blinky I wrote about in this
post, but with lots of comments on every line.</li><li><a href=https://blog.japaric.io/brave-new-io/>Brave new I/O</a>: A more thorough introduction to embedded Rust&rsquo;s approach to
microcontroller code.</li><li><a href=https://github.com/joaocarvalhoopen/How_to_learn_modern_Rust#embedded-rust>Learn modern embedded Rust</a>: A list of resources (very meta) for learning
embedded Rust!</li><li><a href=https://www.anyleaf.org/blog/rust-embedded-ecosystem-and-tools>Rust embedded ecosystem and tools</a>: A list of tools to make embedded Rust
easier and smoother</li><li><a href=https://dev.to/apollolabsbin/demystifying-rust-embedded-hal-split-and-constrain-methods-591e>Demystifying Rust Embedded HAL Split and Constrain Methods</a>: An informative
post about <code>.split()</code> and <code>.constrain()</code>.</li></ul><hr><p>In the next post, I&rsquo;ll go over the <em>debugging</em> ecosystem of embedded Rust and
we&rsquo;ll work on debugging our program by adding different bugs and using different
methods to find them.</p></article></main><footer id=footer>Copyright (c) 2022 Jack Greenberg</footer></body><script>let darkModeState=!1;const useDark=window.matchMedia("(prefers-color-scheme: dark)"),toggle_button=document.querySelector("#toggle-dark");function toggleDarkMode(e){document.documentElement.classList.toggle("dark-mode",e),darkModeState=e}toggleDarkMode(localStorage.getItem("dark-mode")=="true"),useDark.addListener(e=>toggleDarkMode(e.matches)),toggle_button.addEventListener("click",()=>{darkModeState=!darkModeState,toggleDarkMode(darkModeState),localStorage.setItem("dark-mode",darkModeState)})</script></html>